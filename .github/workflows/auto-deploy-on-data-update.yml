name: Auto Deploy on Data Update

# This workflow is triggered automatically when:
# 1. R2 upload trigger worker dispatches this workflow
# 2. Manual trigger via GitHub UI
# 3. Schedule (optional daily check)

on:
  workflow_dispatch:
    inputs:
      trigger:
        description: 'Trigger source'
        required: false
        default: 'manual'
      timestamp:
        description: 'Trigger timestamp'
        required: false

  # Optional: Daily check for data updates
  schedule:
    - cron: '0 2 * * *'  # 2 AM daily

  # Manual trigger: Upload new data to trigger
  repository_dispatch:
    types: [data-updated]

env:
  NODE_VERSION: '20'
  PNPM_VERSION: '8'

jobs:
  check-data-updates:
    name: Check for Data Updates
    runs-on: ubuntu-latest
    outputs:
      has_updates: ${{ steps.check.outputs.has_updates }}
      manifest_version: ${{ steps.check.outputs.manifest_version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check R2 for new manifest
        id: check
        env:
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
        run: |
          # Download latest manifest from R2
          curl -X GET \
            "https://api.cloudflare.com/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/r2/buckets/${R2_BUCKET_NAME}/objects/data/manifest.json" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -o /tmp/manifest.json

          # Extract version
          MANIFEST_VERSION=$(jq -r '.version' /tmp/manifest.json)
          echo "manifest_version=${MANIFEST_VERSION}" >> $GITHUB_OUTPUT

          # Check if version changed from last deployment
          LAST_VERSION=$(cat .last-deployed-version 2>/dev/null || echo "none")

          if [ "$MANIFEST_VERSION" != "$LAST_VERSION" ]; then
            echo "has_updates=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Data updates detected: ${LAST_VERSION} ‚Üí ${MANIFEST_VERSION}"
          else
            echo "has_updates=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No data updates detected"
          fi

  build-and-deploy:
    name: Build and Deploy Frontend
    needs: check-data-updates
    if: needs.check-data-updates.outputs.has_updates == 'true' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Setup pnpm cache
        uses: actions/cache@v3
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Download latest data from R2
        env:
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
        run: |
          echo "üì• Downloading Parquet files from R2..."

          # Create data directory
          mkdir -p public/data/parquet

          # Download manifest
          curl -X GET \
            "https://api.cloudflare.com/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/r2/buckets/${R2_BUCKET_NAME}/objects/data/manifest.json" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -o public/data/manifest.json

          # Download all Parquet files
          # List all files in R2 bucket
          FILES=$(curl -X GET \
            "https://api.cloudflare.com/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/r2/buckets/${R2_BUCKET_NAME}/objects?prefix=data/parquet/" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" | jq -r '.result[].key')

          # Download each file
          for FILE in $FILES; do
            echo "Downloading $FILE..."
            curl -X GET \
              "https://api.cloudflare.com/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/r2/buckets/${R2_BUCKET_NAME}/objects/${FILE}" \
              -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              -o "public/${FILE}"
          done

          echo "‚úÖ Downloaded $(echo "$FILES" | wc -l) files"

      - name: Generate static metadata
        run: |
          echo "üîß Generating static metadata..."

          # Run metadata generation script
          node scripts/generate-static-metadata.js

          echo "‚úÖ Metadata generated"

      - name: Build Next.js application
        env:
          NEXT_PUBLIC_DATA_VERSION: ${{ needs.check-data-updates.outputs.manifest_version }}
          NODE_ENV: production
        run: |
          echo "üèóÔ∏è Building Next.js application..."
          pnpm build
          echo "‚úÖ Build complete"

      - name: Deploy to Cloudflare Pages
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          projectName: neetlogiq
          directory: out
          gitHubToken: ${{ secrets.GITHUB_TOKEN }}

      - name: Save deployed version
        run: |
          echo "${{ needs.check-data-updates.outputs.manifest_version }}" > .last-deployed-version
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add .last-deployed-version
          git commit -m "chore: update deployed version to ${{ needs.check-data-updates.outputs.manifest_version }}" || true
          git push || true

      - name: Invalidate Cloudflare cache
        env:
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          echo "üóëÔ∏è Invalidating Cloudflare cache..."

          curl -X POST \
            "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/purge_cache" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data '{"purge_everything":true}'

          echo "‚úÖ Cache invalidated"

      - name: Send success notification
        if: success()
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          MESSAGE="üéâ *Deployment Successful*%0A%0A"
          MESSAGE="${MESSAGE}üì¶ Version: ${{ needs.check-data-updates.outputs.manifest_version }}%0A"
          MESSAGE="${MESSAGE}üöÄ Deployed to: https://neetlogiq.pages.dev%0A"
          MESSAGE="${MESSAGE}‚è∞ Time: $(date -u +'%Y-%m-%d %H:%M:%S UTC')%0A"
          MESSAGE="${MESSAGE}üîó Commit: ${{ github.sha }}%0A"

          curl -X POST \
            "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=Markdown"

      - name: Send failure notification
        if: failure()
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          MESSAGE="‚ùå *Deployment Failed*%0A%0A"
          MESSAGE="${MESSAGE}‚ö†Ô∏è Please check GitHub Actions logs%0A"
          MESSAGE="${MESSAGE}üîó Run: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}%0A"
          MESSAGE="${MESSAGE}‚è∞ Time: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"

          curl -X POST \
            "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=Markdown"

  health-check:
    name: Post-Deployment Health Check
    needs: build-and-deploy
    runs-on: ubuntu-latest

    steps:
      - name: Wait for deployment to propagate
        run: sleep 30

      - name: Check homepage
        run: |
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" https://neetlogiq.pages.dev)

          if [ "$RESPONSE" = "200" ]; then
            echo "‚úÖ Homepage is accessible (HTTP $RESPONSE)"
          else
            echo "‚ùå Homepage returned HTTP $RESPONSE"
            exit 1
          fi

      - name: Check manifest API
        run: |
          MANIFEST=$(curl -s https://neetlogiq.pages.dev/data/manifest.json)
          VERSION=$(echo $MANIFEST | jq -r '.version')

          if [ -n "$VERSION" ] && [ "$VERSION" != "null" ]; then
            echo "‚úÖ Manifest is accessible (version: $VERSION)"
          else
            echo "‚ùå Manifest is not accessible or invalid"
            exit 1
          fi

      - name: Check cutoffs page
        run: |
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" https://neetlogiq.pages.dev/cutoffs)

          if [ "$RESPONSE" = "200" ]; then
            echo "‚úÖ Cutoffs page is accessible (HTTP $RESPONSE)"
          else
            echo "‚ùå Cutoffs page returned HTTP $RESPONSE"
            exit 1
          fi

      - name: Send health check results
        if: always()
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            MESSAGE="‚úÖ *Health Check Passed*%0A%0A"
            MESSAGE="${MESSAGE}All critical pages are accessible%0A"
            MESSAGE="${MESSAGE}üåê Site: https://neetlogiq.pages.dev"
          else
            MESSAGE="‚ö†Ô∏è *Health Check Failed*%0A%0A"
            MESSAGE="${MESSAGE}Some pages are not accessible%0A"
            MESSAGE="${MESSAGE}Please investigate immediately"
          fi

          curl -X POST \
            "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=Markdown"
