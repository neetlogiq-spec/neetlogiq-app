QUICK REFERENCE: False Matches in recent3.py - Code Locations & Fixes

================================================================================
CRITICAL CODE LOCATIONS - ALL LINKS TO REBUILD
================================================================================

1. MAIN ENTRY POINTS (Parallel Processing)
   Line 13735: def match_and_link_parallel(self, data_source, table_name):
   â””â”€ Line 13919: results_df.to_sql(table_name, conn, if_exists='replace') âŒ NO DEDUP

2. MATCHING PIPELINE - STAGE 4 ADDRESS FILTERING  
   Line 12931: def pass4_final_address_filtering(self, matches, normalized_address):
   â””â”€ Line 13009-13016: Still accepts unvalidated matches âŒ WEAK

3. ADDRESS KEYWORD MATCHING
   Line 13092: def extract_address_keywords(self, address):
   â””â”€ Line 12997: if len(common_keywords) > 0: âŒ TOO FLEXIBLE (1 keyword enough)

4. COMPOSITE_COLLEGE_KEY FALLBACK
   Line 12045: SHORTLIST 2 in pass3_college_name_matching()
   â””â”€ Line 12054-12060: Loses address context when composite_key missing âŒ

5. DATABASE-DRIVEN MATCHING (Tier 2)
   Line 8702-8905: Tier 2 Python post-processing
   â””â”€ NO call to pass4_final_address_filtering() âŒ

6. PARALLEL BATCH PROCESSING
   Line 13863-13912: UPSERT logic in match_and_link_parallel()
   â””â”€ NO check for (college_id + state + address) conflicts âŒ

7. LINK TABLE BUILD & FALSE MATCH DETECTION
   Line 9270: def rebuild_state_course_college_link_text(self):
   â””â”€ Line 9360-9376: DETECTS false matches âœ… (but can't fix)
   â””â”€ Line 9383-9385: Reports "CRITICAL DATA QUALITY ISSUE" âœ…

8. INTEGRITY VALIDATION
   Line 9481: validate_data_integrity() - Check 2: College ID + Address
   â””â”€ Confirms false matches are the problem âœ…

================================================================================
WHERE TO INSERT ADDRESS DEDUPLICATION
================================================================================

INSERT BEFORE LINE 13919 in match_and_link_parallel():

    # DEDUPLICATE by (college_id + state + address)
    def deduplicate_matches(results_df):
        """Remove duplicate college_id assignments per state"""
        dedup_issues = []
        
        for (college_id, state), group in results_df.groupby(['master_college_id', 'state']):
            if group['address'].nunique() > 1:  # Multiple addresses!
                # Keep highest confidence match
                best = group.nlargest(1, 'college_match_score')
                bad = group.drop(best.index)
                
                dedup_issues.append({
                    'college_id': college_id,
                    'state': state,
                    'addresses': group['address'].unique(),
                    'kept_score': best['college_match_score'].values[0]
                })
                
                # Remove the bad matches
                results_df = results_df.drop(bad.index)
        
        return results_df, dedup_issues

    # Line 13836 (before to_sql):
    results_df, dedup_issues = deduplicate_matches(results_df)
    if dedup_issues:
        logger.warning(f"Deduplicated {len(dedup_issues)} false match patterns")

================================================================================
WHERE TO ENFORCE PASS 4 ADDRESS VALIDATION
================================================================================

LOCATION 1: Tier 2 post-processing (Line 8905)
   Current: Results written directly after prefix/fuzzy matching
   Fix: Add before line 8910:
   
   # Apply Pass 4 address filtering
   if normalized_address and best_match:
       pass4_results = self.pass4_final_address_filtering(
           [best_match], normalized_address, normalized_college
       )
       if not pass4_results:
           best_match = None  # Reject due to address mismatch

LOCATION 2: pass4_final_address_filtering() itself (Lines 13009-13016)
   Current: Accepts unvalidated matches (address_validated=False)
   Fix: Change line 13013-13016 to:
   
   else:
       # Specific college with NO address match - REJECT
       logger.debug(f"âŒ ADDRESS REJECTED: {candidate['id']}")
       continue  # Don't include unvalidated match

================================================================================
WHERE TO STRENGTHEN ADDRESS MATCHING
================================================================================

LOCATION: extract_address_keywords() and calculate_keyword_overlap()
Lines 12985-13019

Current Problem:
  - Accepts any 1 common keyword as match
  - No check for ALL master keywords present
  
Fix 1 - Increase minimum keywords:
  Line 12997: Change from:
    if len(common_keywords) > 0:
  To:
    if len(common_keywords) >= 2:  # Require 2+ keywords for generic

Fix 2 - Check master keywords coverage:
  Lines 12989-13019: Add this check:
  
    # ENHANCED: Ensure ALL master keywords are present (not just some)
    master_keywords_found = len(intersection)
    total_master_keywords = len(master_keywords_lower)
    
    if is_generic_college:
        # Generic: All master keywords must be found
        if master_keywords_found < total_master_keywords:
            continue  # Not enough keyword coverage
    
================================================================================
WHERE TO FIX COMPOSITE_COLLEGE_KEY FALLBACK
================================================================================

LOCATION: Lines 12045-12061 in pass3_college_name_matching()

Current fallback loses address context:
    if composite_key and ',' in composite_key:
        candidate_name = self.extract_college_name_from_composite_key(composite_key)
    else:
        # LOSES ADDRESS CONTEXT HERE
        candidate_name = self.normalize_text(candidate.get('name', ''))

Fix: Try multiple approaches:

    if composite_key and ',' in composite_key:
        candidate_name = self.extract_college_name_from_composite_key(composite_key)
        candidate_address = self.extract_address_from_composite_key(composite_key)
    elif candidate.get('address'):
        # FALLBACK 1: Use address column
        candidate_name = self.normalize_text(candidate.get('name', ''))
        candidate_address = self.normalize_text(candidate.get('address', ''))
    else:
        # FALLBACK 2: Just use name (worst case)
        candidate_name = self.normalize_text(candidate.get('name', ''))
        candidate_address = ''

================================================================================
TABLE TO UNDERSTAND FALSE MATCH PATTERNS
================================================================================

Query to find current false matches:

SELECT 
    college_id,
    normalized_state,
    COUNT(DISTINCT seat_address_normalized) as address_count,
    SUM(occurrences) as total_records,
    GROUP_CONCAT(seat_address_normalized, ' || ') as addresses
FROM state_course_college_link_text
GROUP BY college_id, normalized_state
HAVING COUNT(DISTINCT seat_address_normalized) > 1
ORDER BY address_count DESC, total_records DESC;

This shows exactly which colleges are matched to multiple addresses.

================================================================================
TESTING DEDUPLICATION FIX
================================================================================

After implementing deduplication, test with:

    matcher.validate_data_integrity()

Check 2 should now pass (College ID + Address Uniqueness).

Also run:

    matcher.rebuild_state_course_college_link_text()

Should show: "âœ… No false matches detected!" instead of 
            "ðŸš¨ CRITICAL DATA QUALITY ISSUE"

================================================================================
PRIORITY ORDER FOR FIXES
================================================================================

P0 (URGENT):
  1. Add deduplication gate at line 13919
     â†’ Prevents future false matches from being saved

P1 (CRITICAL):
  2. Enforce address_validated==True at line 13009-13016
     â†’ Makes Pass 4 mandatory for all matches
     
  3. Add Pass 4 call after Tier 2 processing (line 8905)
     â†’ Closes database-driven matching gap

P2 (HIGH):
  4. Increase minimum keyword overlap from 1 to 2
     â†’ Strengthens address matching

P3 (MEDIUM):
  5. Fix composite_college_key fallback (line 12054-12060)
     â†’ Preserves address context when composite key missing

P4 (LOW):
  6. Add pre-validation at to_sql() calls
     â†’ Defensive check before saving

